---
title: "Backend & Beyond By Sungwon 😎"
date: "2025-10-17"
description: "안정적인 시스템을 만들고, 새로운 기술을 배웁니다."
cover: "/images/cover-engineer.jpg"
tags:
  [
    "Spring Boot",
    "Kafka",
    "Microservice",
    "Performance",
    "DevOps",
    "Node.js",
    "Next.js",
  ]
---

## <img src="/img/asdasdasd.jpg" alt="" width="100" />

# 박성원 | Backend & Beyond By Sungwon

비효율을 자동화하고, **고객이 진짜 가치 있는 일에 집중할 수 있게 돕는 엔지니어**,  
박성원입니다.  
RPA와 웹 개발(Spring Boot + Node.js)을 함께 수행하며,  
프로세스 자동화부터 웹포털 구축까지 전 주기 개발을 담당해왔습니다.

---

## 🧩 About Me

- **현재** ⏳: 2021.07 ~ 재직 중
- **역할** 💼: RPA 개발 및 자사 솔루션 웹 개발 유지보수

- **학력** 🎓: 한국방송통신대학교 컴퓨터과학과 졸업 (2024.02)
- **이메일** ✉️: thesungwon@gmail.com

- **[GitHub 프로필 보기러가기 🐙](https://github.com/thesungwon) 🔗**

**Skills**

| 영역              | 기술                                                             |
| ----------------- | ---------------------------------------------------------------- |
| Back-End ⚙️       | Java, Spring Boot, JPA, MyBatis, MariaDB, SQL                    |
| Front-End 💻      | JavaScript, TypeScript, React.js, Next.js, Node.js, jQuery, AJAX |
| Automation 🤖     | RPA, VBA, C#, Selenium                                           |
| DevOps / Tools 🛠️ | Linux, Docker, Podman, GitHub, GitLab, Jira, Slack, Teams        |

**As a Developer**
| 항목 | 내용 |
| ------ | ------------------------------------------------------------------- |
| 포지션 | **RPA & Full-Stack Developer** |
| 성향 | 자동화 중심, 문제 해결 지향, 실용적 접근 |
| 목표 | RPA와 웹 기술을 융합하여 효율적인 프로세스 자동화 시스템 구축 |
| 가치관 | 현업 친화적 협업, 가독성과 유지보수성 중심의 코드, 꾸준한 자기 성장 |

> “자동화는 단순한 반복의 제거가 아니라, 사람이 더 창의적인 일에 집중할 수 있게 만드는 기술이라고 믿습니다.”

---

## 🚀 A 증권사 RPA 구축 (1, 2차)

**기간:** 2021(1차), 2022(2차)  
**역할:** RPA 개발  
**성과:** 수작업 업무 자동화

**개요**

여의도 A 증권사의 내부 결재 및 회계, 예탁원 데이터 등록 프로세스를 자동화한 **RPA 구축 프로젝트**입니다.  
반복적이고 오류 발생이 잦던 수작업 업무를 RPA 로직으로 자동화하여  
업무 정확도와 효율성을 높였으며, **1·2차 연도별로 총 11건의 자동화 프로세스**를 개발했습니다.

**주요 기여**

- **결재서류 일괄 전송 자동화**

  - 일일 결재서류를 조회 후 각 부서별 화면에 맞게 자동 업로드
  - 수동 전송 대비 처리 속도 **향상**

- **법인카드 사용내역 검증 자동화**

  - 부서별 근태 데이터와 법인카드 내역을 대조하여 자동 검증

- **예탁원 자료 등록 자동화**

  - 영업일 기준으로 고객사 프로그램을 통해 데이터 수집 및 대사 처리
  - 예탁원 파일 다운로드 및 부서별 파일 자동 전송 로직 구현

- **보수총액 등록 프로세스 개선**
  - 문서 파일 다운로드 후 OCR 수행 → 결과 데이터 자동 추출 및 등록

---

## 🚀 B 보험사 RPA 자동화 시스템

**기간:** 2023 ~ 2024  
**역할:** RPA 개발  
**성과:** 반복 업무 자동화 / 일일 처리량 향상 / 인력 리소스 70% 절감

**개요**

광화문 B 보험사의 보험 관련 업무 전반을 자동화한 **RPA 시스템 구축 프로젝트**입니다.  
수많은 부서별 보험 정보 입력, 파일 업로드, 통계 등록 업무를 자동화하여  
수작업 리소스를 절감하고 정확도 및 속도를 대폭 향상시켰습니다.  
총 **30건 이상의 자동화 시나리오**를 개발 및 운영했습니다.

**주요 기여**

- **부서별 보험 정보 입력 자동화**

  - 부서별 엑셀 보험 정보를 추출하여 고객사 내부 프로그램에 자동 등록
  - 입력 정확도 향상 및 처리 속도 **개선**

- **보험 관련 파일 업로드 자동화**

  - 각 부서의 보험 관련 문서들을 자동 수집 및 업로드

- **보험 통계 자동 등록**

  - 월 1회 부서별 보험 통계 결과 자동 계산 및 프로그램 등록
  - 배치 스케줄링으로 야간 자동 실행 및 리포트 생성

- **운영 및 협업 효율 개선**
  - OneDrive Office, Teams를 통한 RPA 상태 실시간 공유
  - Selenium을 활용한 웹 자동화 테스트 수행

---

## 🚀 C 은행 웹포털 & RPA 통합 시스템

**기간:** 2025 상반기  
**역할:** RPA 및 웹포털 백엔드 개발  
**성과:** 반복 업무 자동화 / 처리 속도 향상 / 사용자 만족도 향상

**개요**

을지로 C 은행의 RPA와 웹포털을 통합한 **자동화 관리 시스템 구축 프로젝트**입니다.  
기존 수작업 데이터 입력 및 결과 검증 과정을 자동화하고,  
웹포털을 통해 OCR 및 RPA 결과를 실시간 조회·관리할 수 있는 환경을 제공했습니다.

**주요 기여**

- **RPA 자동화 로직 설계**

  - 여신사후 정보 입력 자동화: OCR 결과 데이터를 기반으로 고객사 프로그램 자동 입력
  - OCR 추출 결과 정제 및 검증 로직 구현

- **웹포털 개발**

  - OCR 및 RPA 결과 조회 기능 구현
  - Spring Boot 기반 REST API 서버 및 배치 스케줄링 구축
  - 고객사 프로그램과의 데이터 연동 자동화

- **데이터베이스 및 백엔드 최적화**

  - JPA + SQL 병행 적용으로 쿼리 성능 개선

- **운영 효율성 강화**
  - Docker 기반 배포 환경 구축 및 표준화
  - Jira 기반 태스크 관리 및 협업 프로세스 개선

---

## 📘 사이드 프로젝트: Shortify — 실시간 URL 단축 & 로그 분석 백엔드 시스템

**_[GitHub 보기러가기](https://github.com/thesungwon/shortify) 🔗_**

**🧩 프로젝트 개요**

**프로젝트명:** Shortify  
**목표:** 대규모 요청을 안정적으로 처리하고, 실시간 로그 분석 및 비동기 알림 시스템을 구현한 백엔드 서비스 구축.

**🚀 핵심 기능**

| 구분          | 기능 설명                                 |
| ------------- | ----------------------------------------- |
| 🔗 URL 단축   | Base62 인코딩 기반 키 생성 및 Redis 캐싱  |
| 🔁 리다이렉트 | Redis 조회 기반 고속 응답                 |
| 🔐 인증/인가  | Spring Security + JWT                     |
| 📊 로그 수집  | Kafka 기반 비동기 로그 스트리밍           |
| 📬 알림       | RabbitMQ 기반 콘솔 알림 처리              |
| 📈 모니터링   | Prometheus + Grafana 실시간 상태 모니터링 |
| ⚙️ 배포       | Docker                                    |

---

**⚙️ 기술 스택**

| 구분               | 기술                                           |
| ------------------ | ---------------------------------------------- |
| **Backend**        | Java 17, Spring Boot 3.x, Spring Security, JPA |
| **Database**       | MariaDB, Redis                                 |
| **Message Queue**  | Kafka, RabbitMQ                                |
| **Infra & DevOps** | Docker                                         |
| **Monitoring**     | Prometheus, Grafana                            |
| **Docs**           | Swagger                                        |

---

**🌱 애플리케이션 개발**

_🔗 URL 단축 — Base62 인코딩 기반 키 생성 및 Redis 캐싱_

**🧩 AS-IS**

초기에는 단축 URL 요청 시마다 DB를 직접 조회했기 때문에  
요청이 몰리면 **DB 부하가 급격히 증가**하고 응답 속도도 느려졌음.

**💡 TO-BE**

- Redis 캐싱을 사용하여 자주 조회되는 단축 URL은 메모리에서 바로 반환. DB 부담 감소
- Base62 인코딩으로 짧고 고유한 단축 키 생성

**🧠 구현 코드**

```java
//원본 url받아 단축 url생성
    public Url createShortUrl(UrlRequest request){

        String key;
        int attemps = 0;

        do{ //무조건 한 번은 실행
            if(attemps++ > 5) throw new RuntimeException("중복 발생");
            key = KeyGenerator.generateKey(8);

            //Redis setnx
            //만약 키가 존재하지 않는다면(Not Exists), 값을 설정
            Boolean success = valueOps.setIfAbsent("shortKeyLock:" + key, "lock", Duration.ofSeconds(5));
            if(Boolean.TRUE.equals(success)){
                break; //락 성공, key 사용가능
            }
        }while(true); //루프 통과


        Url url =  Url.builder()
                .originalUrl(request.getOriginalUrl())
                .shortKey(key)
                .createAt(LocalDateTime.now())
                .build();
        urlRepository.save(url);

        //락 해제 (5초 후 자동만료, 명시적 삭제)
        redisTemplate.delete("shortKeyLock:" + key);

        return url;
    }

    //단축키 원본 url 찾기
    public String getOriginalUrl(String key){
        Url url = urlRepository.findByShortKey(key)
                .orElseThrow(()-> new RuntimeException("Url not found"));
        return url.getOriginalUrl();
    }
```

---

_🔁 리다이렉트 — Redis 조회 기반 고속 응답_

**🧩 AS-IS**

모든 리다이렉트 요청이 DB에 접근하면서 I/O 병목 발생.  
고빈도 요청(예: 바이럴된 단축 URL)일수록 서버 과부하.

**💡 TO-BE**

Redis에서 단축 URL 조회 → DB 접근 최소화 → 응답 속도 극대화

**🧠 구현 코드**

```java
 //즉시 kafka로그 발행
    //db는 비동기 기록, 리다이렉트 속도 안정화
    @GetMapping("/r/{key}")
    public ResponseEntity<Void> redirect(@PathVariable String key, HttpServletRequest request) {

        String originalUrl = urlService.getOriginalUrl(key);

        String clientIp = request.getRemoteAddr();

        //kafka로그전송
        RedirectLog log = RedirectLog.builder()
                .shortKey(key)
                .timestamp(LocalDateTime.now())
                .clientIp(clientIp)
                .build();
        System.err.println(log);
        logProducer.send(log); //kafka
        notificationProducer.sendNotification(originalUrl); //rabbitmq



        return ResponseEntity.status(302) //Found를 의미
                .location(URI.create(originalUrl))
                .build();
    }
```

---

_🔐 인증/인가 — Spring Security + JWT_

**🧩 AS-IS**

세션 기반 인증 → 서버 재시작 시 세션 소멸, 확장성 제한

**💡 TO-BE**

- **JWT 기반 Stateless 인증 구조**로 전환.
- Refresh Token은 Redis에 저장해 만료 제어 가능하도록 구성.

**🧠 구현 코드**

```java
 //jwt생성
    public String createToken(String username){
        Date now = new Date();
        Date expiry = new Date(now.getTime() + validityInMs);;

        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiry)
                .signWith(SignatureAlgorithm.HS256, secretKey)
                .compact();
    }

    //jwt에서 username 추출
    public String getUsername(String token){
        return Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token).getBody().getSubject();
    }

    //jwt 유효성체크
    public boolean validateToken(String token){
        try{
            Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);
            return true;
        }catch(JwtException | IllegalArgumentException e){
            return false;
        }
    }
```

---

_📊 로그 수집 — Kafka 기반 비동기 로그 스트리밍_

**🧩 AS-IS**

리다이렉트 시 DB에 직접 로그 기록

**💡 TO-BE**

- Kafka Topic에 로그 전송 → DB 비동기 기록
- 별도의 Consumer가 비동기적으로 로그를 수집 후 DB 저장.

**🧠 구현 코드**

```java
public void send(RedirectLog log) {
        System.err.println("(kafka 보냄) producer: "+log);
        kafkaTemplate.send(TOPIC, log.getShortKey(), log);
    }
```

---

_📬 알림 — RabbitMQ 기반 이메일/콘솔 알림 처리_

**🧩 AS-IS**

에러 알림

**💡 TO-BE**

- RabbitMQ 큐에 메시지 전송 → 비동기 처리

**🧠 구현 코드**

```java
public void sendNotification(String message) {
        rabbitTemplate.convertAndSend(NOTIFICATION_QUEUE, message);
        System.err.println("(RABBITMQ) 메세지 보냄 : " + message);
    }
```

---

_⚙️ 배포 — Docker 기반 구성_

**🧩 AS-IS**

로컬 환경에서 수동 빌드

**💡 TO-BE**

- Docker로 컨테이너화

**🧠 구현 코드**

```yaml
name: Deploy Shortifyversion: '3.8'
services:
  mariadb:
    image: mariadb:11
    container_name: shortify-mariadb
    restart: always
    environment:
      MARIADB_ROOT_PASSWORD:
      MARIADB_DATABASE: shortify
      MARIADB_USER: shortify_user
      MARIADB_PASSWORD: shortify_pass
    ports:
      - "3307:3306"
    volumes:
      - ./db_data:/var/lib/mysql

  redis:
    image: redis:7
    container_name: shortify-redis
    restart: always
    ports:
      - "6379:6379"

  zookeeper:
    image: wurstmeister/zookeeper
    container_name: zookeeper
    ports:
      - "2181:2181"

  kafka:
    image: wurstmeister/kafka
    container_name: shortify-kafka
    ports:
      - "9092:9092"
    environment:
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
    depends_on: # Zookeeper가 먼저 실행되도록 명시
      - zookeeper

  kafka-ui:
    image: provectuslabs/kafka-ui:latest
    container_name: shortify-kafka-ui
    ports:
      - "9090:8080"  # 👈 접속 포트 설정 (9090번으로 접속)
    environment:
      # 클러스터 이름 설정
      KAFKA_CLUSTERS_0_NAME: Shortify-Cluster
      # 🚨🚨 가장 중요! 컨테이너 내부 이름으로 Kafka에 접속합니다. 🚨🚨
      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: shortify-kafka:9092
    depends_on:
      - kafka

  rabbitmq:
    image: rabbitmq:3-management
    container_name: shortify-rabbitmq
    ports:
      - "5672:5672" # 메시지 브로커 포트
      - "15672:15672" # 관리 콘솔
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest

```

---

# ✅ 전체 요약

| 기능           | 성능 향상                                                                                                      |
| -------------- | -------------------------------------------------------------------------------------------------------------- |
| URL 단축       | <img src="/img/url.png" alt="" width="500" />                                                                  |
| 리다이렉트     | <img src="/img/shortify.png" alt="" width="500" />                                                             |
| kafka          | <img src="/img/kafka_send.png" alt="" width="500" /> <img src="/img/kafka_receive.png" alt="" width="500" />   |
| rabbitMQ       | <img src="/img/rabbit_send.png" alt="" width="500" /> <img src="/img/rabbit_receive.png" alt="" width="500" /> |
| 알림           | <img src="/img/트래픽.png" alt="" width="200" />                                                               |
| Container 구성 | <img src="/img/docker_desktop.png" alt="" width="500" />                                                       |

---

## 📘 토이 프로젝트: mini game — Next.js 기반 게임 허브

- **_[GitHub 보기러가기](https://github.com/TheSungwon/nextjs_mini_game) 🔗_**
- **_[사이트보러가기](https://nextjs-mini-game.vercel.app/) ⚽_**

**🧩 프로젝트 개요**

**프로젝트명:** nextjs-mini-game

**✨ 주요 기능**

**_1. 🎯 정교한 2D 물리 엔진 구현_**

- **중력 및 마찰**: 모든 공에 일관된 중력과 마찰을 적용하여 실제와 같은 움직임을 구현했습니다.
- **공-공 충돌**: 공들 간의 충돌 시, 완전 탄성 충돌 로직을 적용하여 운동량과 에너지가 보존되도록 처리했습니다.
- **공-장애물 충돌**: 기울어진 막대, 회전하는 막대, 탄성 있는 막대 등 다양한 종류의 장애물과의 충돌을 정교하게 처리합니다. 특히 회전하는 장애물은 충돌 시 공에 회전 운동량을 전달하여 예측 불가능하고 역동적인 플레이를 유도합니다.

**_2. 🎲 동적인 게임 환경_**

- **랜덤 장애물 생성**: 매 게임 시작 시, 기울기, 회전 속도, 탄성 계수가 무작위로 설정된 다양한 형태의 장애물이 자동으로 배치됩니다. 이를 통해 매번 새로운 플레이 경험을 제공합니다.
- **멀티 플레이어 지원**: 여러 명의 플레이어가 동시에 참여하여 경쟁할 수 있도록 설계되었습니다. (현재는 이름 기반의 시뮬레이션)
- **실시간 순위 시스템**: 게임이 종료되면 각 플레이어의 도착 순서를 기반으로 실시간 순위를 표시합니다.

**🛠️ 기술 스택**

- **프론트엔드**: `Next.js 15 (App Router)`, `React 19`, `TypeScript`
- **상태 관리**: `React Hooks (useState, useEffect, useRef)`
- **스타일링**: `Tailwind CSS`
- **UI 컴포넌트**: `Radix UI (@radix-ui/react-progress, @radix-ui/react-slot)`
- **그래픽**: `HTML5 Canvas API`
- **유틸리티**: `clsx`, `tailwind-merge`, `lucide-react`

---

---

## 📘 토이 프로젝트: markdown 블로그 — Next.js 기반 markdown 블로그

- **_[GitHub 보기러가기](https://github.com/TheSungwon/my_blog) 🔗_**
- **_[사이트보러가기](https://sungwon-blog.vercel.app/) 📜_**

**🧩 프로젝트 개요**

**프로젝트명:** my_blog

**✨ 주요 기능**

개발 기록을 담는 개인 블로그입니다. Markdown 기반 포스트를 정적 생성(SSG)하여 빠르고 안정적인 읽기 경험을 제공합니다. 다크 모드, 목차(TOC), 코드 하이라이트 등 글 읽기에 최적화된 UI/UX를 제공합니다.

- **Markdown 포스트**
- **목차 자동 생성**
- **코드 하이라이트**
- **다크 모드 토글**
- **정적 생성(SSG)**
- **타이포그래피 최적화**

**🛠️ 기술 스택**

- **프론트엔드**: `Next.js 15 (App Router)`, `React 19`, `TypeScript`
- **스타일링**: `Tailwind CSS 4`, `PostCSS`
- **Markdown 파이프라인**: `unified`, `remark(remark-parse, remark-gfm, remark-rehype)`, `rehype(rehype-slug, rehype-autolink-headings, rehype-toc, rehype-highlight, rehype-stringify)`, `gray-matter`
- **테마**: `next-themes`

**📁 프로젝트 구조**

```

├─ posts/                # 블로그 글(Markdown)
├─ public/               # 정적 자산(아이콘/이미지)
├─ src/
│  ├─ app/
│  │  ├─ components/    # 레이아웃 관련 컴포넌트(Header, Providers)
│  │  ├─ posts/
│  │  │  ├─ page.tsx    # /posts 목록 페이지
│  │  │  └─ [slug]/
│  │  │     └─ page.tsx # /posts/[slug] 상세 페이지
│  │  ├─ layout.tsx     # 전역 레이아웃(메타/헤더/Providers)
│  │  ├─ page.tsx       # 루트 인덱스(포스트 카드 그리드)
│  │  └─ globals.css    # 전역 스타일(타이포그래피/TOC/다크)
│  ├─ components/
│  │  └─ ThemeToggle.tsx
│  └─ lib/
│     ├─ markdown.ts    # Markdown → HTML 변환 + TOC 생성
│     └─ posts.ts       # 포스트 읽기/메타/정적 파라미터
├─ package.json
├─ next.config.ts
├─ tailwind.config.ts
├─ postcss.config.mjs
├─ tsconfig.json
└─ eslint.config.mjs
```

---

# 감사합니다 ! 😄
